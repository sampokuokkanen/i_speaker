{
  "title": "What is happening with strings in Ruby and why is it feeling chilly? 🥶",
  "description": "Explore the recent changes to frozen string literals in Ruby, their implications for everyday Rubyists, and why strings are feeling 'chilly' in the latest versions.",
  "target_audience": "RubyConf Taiwan attendants",
  "duration_minutes": 30,
  "slides": [
    {
      "title": "Welcome to RubyConf Taiwan! 🇹🇼",
      "content": [
        "Hello Ruby developers of Taiwan! 你好！",
        "Taiwan's tech scene: From semiconductor leadership to Ruby innovation"
      ],
      "notes": "Warm welcome to the local audience and acknowledge Taiwan's tech leadership.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Why Taiwan Matters in Ruby 💎",
      "content": [
        "Why Taiwan matters in the Ruby ecosystem:",
        "• Strong open-source community",
        "• Active Ruby developers and companies",
        "• Bridge between Eastern and Western Ruby communities",
        "",
        "Today's journey: How Ruby makes decisions (spoiler: very carefully!)"
      ],
      "notes": "Set the stage for discussing Ruby's cautious decision-making process.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Demo Code 📝",
      "content": [
        "```ruby",
        "# Our demo with Taiwan companies:",
        "company = \"台積電\"  # TSMC",
        "puts company.frozen?  # => true",
        "",
        "# Try to mutate it:",
        "company << \" 台灣\"",
        "# ⚠️  Warning: literal string will be frozen",
        "",
        "puts company         # => \"台積電 台灣\"", 
        "puts company.frozen? # => false",
        "```"
      ],
      "notes": "Code details for reference.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "About Your Speaker: Sampo Kuokkanen 🚀",
      "content": [
        "Head of Evil Martians Japan Office",
        "Building bridges between Ruby communities worldwide",
        "• Co-presented at RubyWorld 2024 with Andrey Novikov",
        "Why I'm here: Taiwan + Japan = Ruby powerhouse in Asia!"
      ],
      "notes": "Brief introduction. Emphasize the Japan-Taiwan connection and my role in bridging Ruby communities. Mention Evil Martians' commitment to the Asian Ruby scene.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The String Performance Problem (?) in Ruby",
      "content": [
        "Ruby's mutable strings: convenient and fun, but costly",
        "String allocations are a major contributor to GC pressure",
        "The solution: Immutability through frozen and chilled strings"
      ],
      "notes": "Start with a relatable problem statement. Ask audience: 'How many of you have dealt with memory issues in your Ruby apps?' Use this to establish why string handling matters to everyone, not just core developers.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Introduction",
      "content": [],
      "notes": "",
      "image_path": "/Users/sampokuokkanen/i_speaker/Keeping it Ruby_ Why Your Product Needs a Ruby SDK-2.jpg",
      "slide_type": "image"
    },
    {
      "title": "Evil Martians: Product Development for the Web 👽",
      "content": [
        "Design + Development + Growth consultancy",
        "• Open Source contributors (AnyCable, PostCSS)",
        "• Ruby/Rails experts since 2005",
        "• Global team: SF, NYC, Barcelona, Lisbon, Japan",
        "Japan office established: May 2022 🇯🇵",
        "Our mission in Asia: Strengthen Ruby communities!"
      ],
      "notes": "Quick Evil Martians intro. Emphasize our commitment to open source and the Asian Ruby community.",
      "image_path": "/Users/sampokuokkanen/i_speaker/Keeping it Ruby_ Why Your Product Needs a Ruby SDK-3.jpg",
      "slide_type": "mixed"
    },
    {
      "title": "Evil Martians Japan",
      "content": [],
      "notes": "",
      "image_path": "/Users/sampokuokkanen/i_speaker/Keeping it Ruby_ Why Your Product Needs a Ruby SDK-4.jpg",
      "slide_type": "mixed"
    },
    {
      "title": "Ruby Pre-2.3: The Manual Era",
      "content": [
        "Strings always mutable by default",
        "Developers used ''.freeze for constants",
        "Memory issues: every string literal created a new object"
      ],
      "notes": "Set the stage - before optimizations, every string was a separate object in memory.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Ruby 2.1: The Deduplication Breakthrough",
      "content": [
        "Major optimization: .freeze now deduplicates identical literals",
        "Same frozen strings share memory locations",
        "Dramatic memory usage reduction",
        "",
        "Example:",
        "• Before: Each 'hello'.freeze = new object",
        "• After: All 'hello'.freeze = same object"
      ],
      "notes": "Ruby 2.1 was the first major step toward efficient string handling. This optimization made .freeze actually useful for performance.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Surprising Behavior Before Ruby 2.1",
      "content": [
        "**Before Ruby 2.1**: Each .freeze created a new object",
        "",
        "```ruby",
        "# Ruby 2.0 and earlier - SURPRISE!",
        "\"hello\".freeze == \"hello\".freeze  # => false (!)",
        "\"hello\".freeze.object_id == \"hello\".freeze.object_id  # => false",
        "```",
        "",
        "**After Ruby 2.1**: Deduplication makes them identical",
        "",
        "```ruby", 
        "# Ruby 2.1+ - Expected behavior",
        "\"hello\".freeze == \"hello\".freeze  # => true",
        "\"hello\".freeze.object_id == \"hello\".freeze.object_id  # => true",
        "```"
      ],
      "notes": "This surprises many newer Ruby developers! Before 2.1, frozen strings with identical content were still separate objects. This made .freeze almost useless for performance.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Magic Comment Origin Story",
      "content": [
        "**October 2013**: Akira Tanaka proposes frozen_string_literal",
        "**August 2015**: Akira Matsuda revives the discussion", 
        "**September 2015**: Matz approves for Ruby 2.3",
        "**Ruby 2.3 (2015)**: Magic comment implemented",
        "",
        "Matz's reluctant approval: \"I don't like pragmas but if it is required\"",
        "",
        "Source: Ruby Issue #8976 - https://bugs.ruby-lang.org/issues/8976"
      ],
      "notes": "Give proper attribution to the creators and show the multi-year discussion process. This was not a quick decision!",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Great Debate: Charles Nutter's Opposition (2013)",
      "content": [
        "**Charles Nutter (JRuby creator) was strongly opposed:**",
        "",
        "\"*It would be a very bad idea to have a directive that completely changes the meaning of code from one file to another.*\"",
        "",
        "**His key concerns:**",
        "• File-to-file inconsistency: same code, different behavior",
        "• Developer confusion: frozen errors in some files, not others", 
        "• Forced workarounds: must use String.new() instead of \"\"",
        "",
        "**Counter-argument (Brian Shirai):** \"Encoding pragma already does this!\""
      ],
      "notes": "Note that this was 12 years ago! Show the contentious debate. Charles's concerns about inconsistency are exactly what many developers still worry about today. This wasn't a unanimous decision!",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Ruby 2.3 and Beyond",
      "content": [
        "Ruby 2.3: Magic comment goes live as **experimental feature**",
        "Original goal: Migration path toward Ruby 3.0 default frozen literals",
        "Ruby 3.0 plan: Default frozen literals postponed due to compatibility",
        "Ruby 3.3+: Introduction of 'chilled strings' as new transition mechanism"
      ],
      "notes": "Present the timeline progression from experimental pragma to the current chilled string approach. Emphasize the experimental nature.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Why Chilled Strings? The Migration Challenge",
      "content": [
        "The goal: Default frozen literals for performance",
        "The problem: Breaking existing code that mutates literals",
        "The solution: Gradual transition with warnings",
        "Chilled strings = Frozen initially + Warning on mutation",
        "This approach maintains compatibility while encouraging best practices"
      ],
      "notes": "Explain the 'why' before the 'how'. This addresses the issue of premature technical depth. Use the chilly metaphor consistently - strings are 'chilled' (frozen) but can be 'warmed up' (mutated) with a warning.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Chilled Strings: What They Are",
      "content": [
        "Ruby 3.3 introduces the putchilledstring instruction",
        "Chilled strings: appear frozen but can 'thaw' with warnings",
        "Key insight: Mixed benchmark results in real applications"
      ],
      "notes": "Introduce the basic concept of chilled strings before diving into implementation details.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Chilled Strings: Technical Implementation",
      "content": [
        "Technical implementation (from Ruby Issue #20205):",
        "• putchilledstring creates strings with special flags",
        "• STR_CHILLED flag marks the string as 'thawed-on-write'",
        "• .frozen? returns **false** (changed after RubyKaigi!)",
        "• First mutation: warning + string becomes mutable",
        "• Performance impact: minimal overhead (< 1%)"
      ],
      "notes": "Present the technical implementation details. Note that frozen? behavior was changed from the original plan.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Chilled Strings: Performance Reality",
      "content": [
        "Reality: Performance gains are often marginal (5-30%)",
        "The real goal: Gradual migration to immutability",
        "",
        "Not about dramatic speedups – about preparing for the future"
      ],
      "notes": "Focus on the behavior rather than low-level implementation details. Use the example to make the concept concrete.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Why frozen? Returns False: The RubyKaigi Decision",
      "content": [
        "**Original plan**: `'hello'.frozen?` → `true` for chilled strings",
        "**Problem**: Caused confusion and potential bugs",
        "**The issue**: `str.dup if str.frozen?` pattern breaks",
        "",
        "**After RubyKaigi discussions with Matz**:",
        "• Changed to return `false` to avoid false positives",
        "• Better to have explicit warnings than silent corruption",
        "",
        "Source: Ruby Issue #20205, Jean Boussier's experiments"
      ],
      "notes": "Explain the decision-making process behind the frozen? behavior change. This addresses community confusion and shows Ruby's responsiveness to feedback.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Why Chilled Strings? The Migration Challenge",
      "content": [
        "Goal: Make string literals frozen by default (Ruby 4.0)",
        "Challenge: Backward compatibility with existing code",
        "Solution: Gradual transition through 'chilled' strings",
        "Chilled strings = frozen initially, warn on mutation"
      ],
      "notes": "Explain the rationale before diving into implementation. Use an analogy: 'Chilled strings are like training wheels - they let you know when you're doing something that won't work in the future, but won't crash your program immediately.'",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Evolution of String Immutability in Ruby",
      "content": [
        "Ruby 2.1: Optimized .freeze for deduplication",
        "Ruby 2.3: Introduced # frozen_string_literal: true pragma",
        "Ruby 2.7+: Added deprecation warnings for mutating literals",
        "Ruby 3.3: Implemented chilled strings (R0 transition phase)",
        "Future (Ruby 4.1+): Planned default frozen literals (R2)"
      ],
      "notes": "Present this as a clear timeline visualization. Emphasize that this has been a decade-long journey showing Ruby's commitment to both performance and backward compatibility. This replaces the repetitive historical content across multiple slides.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The State of Strings in Ruby 3.3",
      "content": [
        "Starting with Ruby 3.3 (R0), strings without `# frozen_string_literal` use `putchilledstring`",
        "The `putchilledstring` opcode creates chilled strings",
        "**Key behavior**: `String#frozen?` returns **false** (changed from original plan!)",
        "On first mutating operation: warning + string becomes mutable"
      ],
      "notes": "In Ruby 3.3, chilled strings return false for frozen? - this was changed from the original plan after community feedback and RubyKaigi discussions.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Ruby Archaeology: The Origins of Frozen Strings",
      "content": [
        "Ruby’s design was pragmatic: mutable strings by default (like Perl) made life easier for programmers at some performance cost.",
        "Over time, developers demanded immutability for performance; Ruby added deduplication on `.freeze` in 2.1.",
        "By Ruby 2.3, the magic comment emerged to freeze literals in a file when needed – an important milestone in Ruby’s string evolution."
      ],
      "notes": "A lighthearted start – but the technical core is that Ruby always favored mutable strings for flexibility. The move to immutability is recent and driven by memory/GC concerns.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Ruby Archaeology: The Origins of Frozen Strings",
      "content": [
        "Before frozen literals, people often wrote `''.freeze` on constants to avoid duplicate allocations. Ruby 2.1 changed behavior so that freezing identical literals would dedupe them in memory.",
        "This saved RAM and reduced GC churn. For example, avoiding one redundant allocation per call (like an HTTP header) could cut 20–30% of GC work.",
        "The `# frozen_string_literal: true` comment (Ruby 2.3) formalized this idea: any literal in that file would be deduplicated and immutable.",
        "Ultimately, Matz aims for default immutability, but needed a smooth migration plan (hence staged deprecation and warnings)."
      ],
      "notes": "History recap: how `.freeze` became more efficient (dedupe), how that led to the magic comment, and why it’s needed (performance/GC).",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Ruby's String Class History (Deeper Dive)",
      "content": [
        "Ruby 1.9: Added encoding support (m17n) - strings remained mutable",
        "Ruby 2.1: Introduced frozen string deduplication for memory savings",
        "Ruby 2.3: Added `# frozen_string_literal: true` pragma"
      ],
      "notes": "Implementation note: MRI vs JRuby vs Truffle. We focus on MRI, but JRuby has its own approach (Java strings) and Truffle leaves dynamic strings mutable (but core code is frozen).",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Real-World Performance Gains",
      "content": [
        "Let's benchmark frozen vs mutable strings in real-time! 🚀",
        "",
        "🎯 **Press ENTER to run live benchmark!**",
        "",
        "We'll test 1 million string concatenations:",
        "• Mutable strings: `'Hello ' + 'World'`",
        "• Frozen strings: `'Hello '.freeze + 'World'.freeze`",
        "",
        "See the actual performance difference in seconds!"
      ],
      "notes": "INTERACTIVE BENCHMARK: Press ENTER to run the performance comparison live! This will show the actual time difference between mutable and frozen strings. The results typically show 20-35% improvement with frozen strings. Make sure to point out the time difference to the audience.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "What Are Chilled Strings? (Example)",
      "content": [
        "Example: Without `# frozen_string_literal`, Ruby 3.3 compiles `s = \"hello\"` as a chilled string. If `s` is never mutated, it stays frozen and reused.",
        "If later code does `s << ' world'`, Ruby emits a warning (`literal string will be frozen in future`) and then allows the mutation (s becomes mutable).",
        "For most code where literals aren’t changed, chilled strings behave exactly like frozen ones – the literal is shared instead of duplicated."
      ],
      "notes": "We walk through code: chilled string then thawed on mutation. This means in practice you can leave code as-is; if you do mutate a literal, you get a warning and then normal behavior.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "String Duplication Basics in Ruby",
      "content": [
        "When you need a mutable copy of a string:",
        "",
        "```ruby",
        "str = 'hello'.freeze",
        "",
        "# Method 1: Unary plus (Ruby 2.3+)",
        "copy1 = +str            # Concise, returns mutable copy",
        "",
        "# Method 2: String concatenation", 
        "copy2 = str + ''        # Fast, idiomatic",
        "",
        "# Method 3: Duplication",  
        "copy3 = str.dup         # Clear intent, now fast in 3.3+",
        "",
        "# Method 4: Cloning",
        "copy4 = str.clone       # Preserves frozen state",
        "",
        "# Method 5: String constructor",
        "copy5 = String.new(str) # Explicit new object",
        "```"
      ],
      "notes": "Establish the foundation - these are the main ways Ruby developers create mutable copies. Each has different use cases and performance characteristics.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Performance Benefits",
      "content": [
        "Freezing literals cuts object allocations",
        "Identical constants can be shared, reducing GC work",
        "",
        "Benchmarks show gains:",
        "• Ruby 2.7: 22% speedup concatenating 1M strings",
        "• Ruby 3.4-dev: 34% faster with frozen literals"
      ],
      "notes": "Performance recap: frozen literals mean fewer allocations and less GC pressure.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Why .dup Was Slow Before Ruby 3.3",
      "content": [
        "**The old pattern**: `str + ''` was faster than `str.dup`",
        "**Why?** String concatenation had better optimizations",
        "",
        "Ruby 3.3 fixed this imbalance:",
        "• Optimized String#dup implementation", 
        "• Now `str.dup` performs as well as `str + ''`",
        "• Better support for explicit mutability patterns"
      ],
      "notes": "Before Ruby 3.3, developers avoided .dup because string concatenation was more optimized. This created awkward patterns like `str + ''` for copying strings.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Real-World Performance Impact",
      "content": [
        "Rails has reported significant memory savings from frozen literals",
        "Ruby often spends ~20-30% time in GC, so memory savings = speedups",
        "",
        "**Now with Ruby 3.3's .dup optimization:**",
        "• Clean, readable code: `str.dup` instead of `str + ''`",
        "• No performance penalty for explicit mutability",
        "• Better ergonomics for frozen string workflows"
      ],
      "notes": "Combine memory savings from frozen literals with better ergonomics from .dup optimization. This makes the transition to frozen strings much smoother.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Ruby's Cautious Decision-Making",
      "content": [
        "The Ruby Way: Compatibility above all else",
        "• 10+ years of discussion for this feature",
        "• Multiple RFCs, endless bikeshedding, community input",
        "• 'Better safe than sorry' philosophy"
      ],
      "notes": "Emphasize Ruby's philosophy of prioritizing compatibility.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Famous Ruby Timeline",
      "content": [
        "Why so slow? Ruby values backward compatibility over speed",
        "",
        "The famous Ruby decision timeline:",
        "• **2013**: Akira Tanaka proposes frozen_string_literal (Issue #8976)",
        "• **2015**: Magic comment implemented in Ruby 2.3",
        "• **2024**: Chilled strings finally implemented (Issue #20205)",
        "• **2025+**: Still debating R1/R2 phases",
        "",
        "**11+ years** and counting!"
      ],
      "notes": "Perfect example of Ruby's philosophy - this is a culture that values not breaking existing code over rapid innovation. Updated with correct dates and attribution.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Impact on Everyday Rubyists: The Basics",
      "content": [
        "Code with `# frozen_string_literal: true` is unaffected – literals were already frozen.",
        "Without the pragma, strings warn on mutation then become mutable",
        "Common idioms (`dup if frozen?`) still work fine"
      ],
      "notes": "If you already use the magic comment, nothing changes. Otherwise you'll get warnings on mutation.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Impact on Everyday Rubyists: Watch Out!",
      "content": [
        "⚠️ GOTCHA: Chilled string as Hash key bug",
        "If you use a chilled string as a hash key then mutate it, the hash gets corrupted",
        "",
        "Workflow tip: Add `frozen_string_literal` to new files",
        "Use `str.dup` or `+''` when you need mutable copies (now equally fast)",
        "",
        "Source: Ruby Issue #20205"
      ],
      "notes": "Watch out for the hash-key corruption issue. Continue to use dup/+ for copies; they're fast now.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Real-World Impact: A Case Study",
      "content": [
        "**Lobsters.rs (2019, Ruby 2.6)**: ~5% faster with frozen literals",
        "**String concatenation loop (Ruby 2.7, 2020)**: 22% performance gain",
        "**Ruby 3.4-dev (2024)**: 34% faster with frozen string literals",
        "**GitHub.com (Ruby 3.3, 2024)**: 5% fewer allocations using Symbol#name",
        "",
        "💡 **Key insight**: Even 5% matters at scale!"
      ],
      "notes": "Case studies: see actual speed-ups from frozen literals, and note that even large systems like GitHub see ~5% fewer allocations by changing symbol-to-string behavior.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The R0/R1/R2 Migration Strategy: Ruby's Master Plan",
      "content": [
        "Ruby's three-phase approach:",
        "• **R0** (Ruby 3.3): Chilled strings + warnings",
        "• **R1** (Future): Warnings always visible",  
        "• **R2** (Ruby 4.0+): Frozen by default",
        "",
        "🎯 **The reality**: Timeline is flexible by design",
        "Ruby won't break your code for small performance gains!"
      ],
      "notes": "Based on Ruby Issue #20205. Highlight that even the timeline is tentative - Ruby doesn't commit to breaking changes lightly.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Road Not Taken: \"hello\"f Suffix Syntax",
      "content": [
        "Before magic comments, Ruby considered a different approach:",
        "",
        "**The \"f\" suffix proposal (Ruby Issue #8579):**",
        "```ruby",
        "name = \"Hello World\"f      # Frozen string",
        "greeting = \"Welcome\"f      # Frozen string", 
        "```",
        "",
        "vs. current approach:",
        "```ruby",
        "# frozen_string_literal: true",
        "name = \"Hello World\"       # File-level magic",
        "```"
      ],
      "notes": "Historical context: Ruby considered f-suffix but chose magic comments instead.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The f-Suffix: Technical Effectiveness",
      "content": [
        "**Regular string**: `\"hello world\"`",
        "```",
        "putstring \"hello world\"  # Creates new object each time",
        "```",
        "",
        "**F-suffix string**: `\"hello world\"f`", 
        "```",
        "putobject \"hello world\"  # Reuses same frozen object",
        "```",
        "",
        "**Key difference**: putstring vs putobject bytecode",
        "• putstring = new object every time (garbage)",
        "• putobject = reuse same frozen object (efficient)"
      ],
      "notes": "The f-suffix proposal was technically sound - it would have generated more efficient bytecode. This shows the technical merit behind the proposal, even though it was rejected for aesthetic reasons.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Why \"hello\"f Was Rejected",
      "content": [
        "Despite technical merit, community feedback was negative:",
        "• **\"Ugly\" syntax** - Didn't feel Ruby-like",
        "• **Too verbose** - Every string needs tagging",
        "• **Breaking change** - Incompatible with older Ruby",
        "• **RubyShift 2013** - Audience reaction was poor",
        "",
        "✨ **Ruby chose elegance**: File-level magic comments",
        "",
        "Source: https://bugs.ruby-lang.org/issues/8579"
      ],
      "notes": "Historical context: Ruby seriously considered f-suffix syntax but community reaction was negative. The magic comment approach was more Ruby-like - elegant, file-level, and doesn't require tagging every string. This shows Ruby's commitment to beautiful, readable code over pure performance.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Best Practices for Using Frozen String Literals",
      "content": [
        "**1. Add the magic comment to new files:**",
        "`# frozen_string_literal: true`",
        "",
        "**2. When you need mutable strings:**", 
        "• Use `str.dup` (optimized in Ruby 3.3+)",
        "• Or use `str + ''` for concatenation",
        "",
        "**3. Enable warnings in development:**",
        "`Warning[:deprecated] = true`"
      ],
      "notes": "Practical advice for developers. Tools like RuboCop can auto-insert the magic comment.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Code Example: Frozen Strings in Practice",
      "content": [
        "```ruby",
        "# frozen_string_literal: true",
        "",
        "HEADER = \"Processing: \"  # Frozen automatically",
        "",
        "def process(input)",
        "  # ❌ WRONG: HEADER << input  # FrozenError!",
        "  # ✅ RIGHT: Use .dup",
        "  result = HEADER.dup",
        "  result << input",
        "end",
        "```"
      ],
      "notes": "Recommendations: use the magic comment to benefit immediately. Also update your code: prefer `dup` instead of bang methods, since dup is now fast. And run tests with warnings enabled to find any problems.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Alternate Syntax: `'f'` Suffix",
      "content": [
        "A proposed approach was an `f`-suffix on string literals (e.g. `\"hello\"f`) to freeze them.",
        "Criticisms: this syntax was considered \"ugly\" and incompatible with older Ruby (it required tagging each literal).",
        "In a RubyShift 2013 presentation, audience reaction to the `f`-suffix was reported as negative.",
        "Consequently, Ruby 2.3 instead adopted the file-level `# frozen_string_literal: true` magic comment approach."
      ],
      "notes": "History: an `f`-suffix was once discussed (to write frozen literals as `\"text\"f`), but it was rejected in favor of the magic comment.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Ruby Core Decision Timeline",
      "content": [
        "The plan to make literals frozen by default in Ruby 3.0 was abandoned due to backward-compatibility concerns.",
        "Instead, the core team agreed on a staged migration: R0 (e.g. Ruby 3.4) adds deprecation warnings, R1 (later 3.x) shows warnings unconditionally, and R2 (Ruby 4.0) eventually freezes literals by default.",
        "However, Matz has stated that Ruby 4.0 (target ~2025) will still *not* enable default frozen literals yet.",
        "This cautious, decade-long process reflects the community’s emphasis on compatibility and a smooth transition."
      ],
      "notes": "Summary: Ruby 2.3’s default-change was delayed, and the R0/R1/R2 timeline was set. Even so, default freeze in 4.0 is postponed, pending broad adoption and testing.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Future of Frozen String Literals",
      "content": [
        "The long-term plan is to make frozen string literals the default (likely around Ruby 4.0).",
        "Eventually the magic comment will be unnecessary. Deprecation periods ensure a smooth transition.",
        "Gem maintainers should audit their code: add the pragma where safe, or avoid mutating literals in libraries.",
        "These changes will allow further optimizations under the hood (e.g. static string internals, CoW mechanisms)."
      ],
      "notes": "Looking ahead: prepare for Ruby 4.0 default. The ecosystem needs to opt-in now to minimize friction. In return we get faster strings across the board.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Future of Frozen String Literals (Specs)",
      "content": [
        "In Ruby 3.4+, the scheme is: R0 = warnings on mutation if no pragma, R1 = warnings always, R2 = freeze by default.",
        "Ruby 3.4 already issues warnings for mutating literals without the comment.",
        "Symbol-related changes (Symbol#to_s now chilled) and other corner cases are being addressed as part of this transition.",
        "The final switch (default freeze) will come in a future release (likely Ruby 4.0), after a full deprecation cycle."
      ],
      "notes": "Specifically: Ruby 3.4 uses `putchilledstring` by default and warns on mutation:​. Further steps (R1/R2) will follow in 3.5+ and Ruby 4.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Impact on Symbol Strings",
      "content": [
        "Symbols themselves are immutable as always. But converting symbols to strings (`#to_s`) now plays better with frozen-literal strategy.",
        "Ruby 3.4 implemented that `Symbol#to_s` returns a chilled string, reducing string allocations:​.",
        "This change was driven by usage patterns (often `to_s` on symbols in hot paths) and gives performance win without changing APIs.",
        "In practice, you shouldn’t need to change code: `:foo.to_s` behaves as before, but now yields a string that will warn if mutated."
      ],
      "notes": "A quick note on symbols: to reduce allocations, Ruby will mark the string from `Symbol#to_s` as chilled. No direct action needed in your code yet.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Real-World Impact: Another Case Study",
      "content": [
        "Enterprise apps: developers report that turning on frozen literals in Rails apps cuts memory use and slightly speeds up request throughput.",
        "The cumulative effect of many small literal optimizations can be significant under load (e.g. caching, tokenization).",
        "Tools like RuboCop (Style/FrozenStringLiteralComment) help automate the change across a codebase.",
        "Bottom line: teams using frozen literals saw smoother operation and no major breakage, validating the change."
      ],
      "notes": "Another data point: adoption in Rails and large codebases has been largely positive. Profilers show reduced GC and similar or improved latency.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Migration Guide: Preparing Your Codebase",
      "content": [
        "Step 1: Enable warnings in development (Warning[:deprecated] = true)",
        "Step 2: Use RuboCop to add # frozen_string_literal: true automatically",
        "Step 3: Fix warnings by adding .dup or +'' where mutation is needed",
        "Step 4: Test thoroughly - especially edge cases with Hash keys",
        "Step 5: Monitor performance and memory usage improvements"
      ],
      "notes": "This addresses the critical gap identified in the analysis. Make this actionable with specific commands and tools. Emphasize that this is a gradual process that can be done incrementally. Provide a clear path forward for attendees to apply this knowledge.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "RuboCop's Strong Opinions 💪",
      "content": [
        "RuboCop really doesn't like `frozen_string_literal: false`:",
        "",
        "```ruby",
        "# This triggers a warning!",
        "# frozen_string_literal: false",
        "# ⚠️ Style/FrozenStringLiteralComment:", 
        "#    Frozen string literal comment must be set to `true`",
        "```",
        "",
        "**RuboCop's philosophy**: Push developers toward better practices",
        "• Defaults assume you want performance improvements",
        "• `false` is seen as intentionally opting out",
        "• Tool culture reinforces Ruby's direction"
      ],
      "notes": "Interesting cultural aspect - even the tooling has opinions about which direction Ruby should go! RuboCop acts as a gentle pressure toward frozen strings.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Ruby's Philosophy: Lessons for Taiwan's Tech Scene",
      "content": [
        "What Ruby's cautious approach teaches us:",
        "• Stability enables innovation (like Taiwan's semiconductor industry)",
        "• Community consensus > individual brilliance",
        "• Long-term thinking over quick wins",
        "Taiwan's tech wisdom parallels Ruby's:",
        "• Precision and reliability first (TSMC approach)",
        "• Careful iteration and improvement",
        "• Building sustainable ecosystems, not just features",
        "Question: How does your team balance innovation vs. stability?"
      ],
      "notes": "Connect Ruby's development philosophy to Taiwan's tech culture. Both prioritize long-term stability and careful decision-making.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Interactive Break: Q&A Session",
      "content": [
        "Take a few minutes to ask any questions and clarify doubts you may have about frozen and chilled strings.",
        "特別歡迎中文問題! (Chinese questions especially welcome!)"
      ],
      "notes": "",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Best Practices for Testing with Frozen String Literals",
      "content": [
        "Enable deprecation warnings in tests (`Warning[:deprecated] = true` or `ruby -W:deprecated`) to catch literal-mutation issues.",
        "Use RuboCop’s FrozenStringLiteralComment cop to add or check the magic comment.",
        "Test for immutability: e.g. verify that constants aren’t modified by functions, or use `assert_equal constant, constant.dup`.",
        "Consider continuous integration: treat warnings as errors during upgrade to catch any new mutations."
      ],
      "notes": "In testing, we want to fail fast. For example, enable Ruby warnings so that any literal mutation shows up in CI (RSpec is working on this; Minitest already does it).",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Transition Slide: We’re Halfway There!",
      "content": [
        "Let’s take a quick glance back at what we’ve covered so far.",
        "History of immutable strings, frozen_string_literal magic, chilled strings, and performance impacts."
      ],
      "notes": "Quick summary: we’ve traced the story up to current chilled strings and performance. Next we’ll continue with quality impacts and final examples.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Impact on Code Quality and Readability",
      "content": [
        "Immutable strings can make code safer (fewer unintended side effects). They reduce bugs where a string constant changes underfoot.",
        "However, some developers have noted surprises: e.g. using a frozen string constant in a destructive method (like `transform_values!`) can quietly modify the shared data unexpectedly.",
        "In general, using frozen literals pushes you to think functionally (avoid side effects). It can improve clarity by removing manual `.freeze` calls, but requires awareness of immutability.",
        "With warnings and tests in place, most teams find frozen literals improve code quality, as mutation becomes explicit (`dup` or reassignment)."
      ],
      "notes": "Reflection: immutability is a trade-off. It avoids a class of bugs, but can surprise developers not expecting it. The community discussion noted that behavior like in this example was new.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Real-World Impact: A Final Example",
      "content": [
        "Example (web request header): Without frozen literals, code often did `env[HTTP_PATH_INFO.dup]` on each request, allocating a new string each time. With a frozen literal, that extra allocation is eliminated.",
        "Jean Boussier explains that avoiding such duplicate allocations significantly reduces GC overhead (Ruby spent ~20-30% time in GC before).",
        "Thus freezing a literal key (or using a chilled string) removes a trivial inefficiency that adds up under high load.",
        "Tiny optimizations like this, multiplied across a large app, yield measurable performance improvements in production."
      ],
      "notes": "Concrete snippet: turning `'HTTP_PATH_INFO'` into a frozen literal means `env[...]` avoids a `.dup` every time. That one allocation per request disappears.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Interactive Break 3: Exercise - Try It Out!",
      "content": [
        "Take a few minutes: add `# frozen_string_literal: true` to a Ruby file or script, and see if any warnings appear or behavior changes."
      ],
      "notes": "",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Conclusion (Part 1): Recap and Reflection",
      "content": [
        "We summarized the history: Ruby 2.3’s frozen-string pragma through Ruby 3.3’s chilled-strings change.",
        "Frozen literals reduce GC and speed up code in many cases.",
        "Chilled strings provide a gentle migration (warn vs error) to default immutability.",
        "Key takeaway: use frozen literals now and explicitly handle mutability to prepare for future Ruby defaults."
      ],
      "notes": "Recap: we covered the key points and rationale behind frozen strings and chilled strings, and why it matters for performance and safety.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Conclusion (Part 2): The Future of Ruby Strings",
      "content": [
        "The likely future: Ruby 4.0 will default to frozen literals, as envisioned years ago.",
        "By then, code will have adapted (we’ll use `dup` or constructors for mutable needs) and will have benefitted from the optimization.",
        "Beyond freezing, Ruby may introduce further innovations (e.g. string dedup internals, CoW, new literal syntax).",
        "Until then, frozen literals remain a great tool for performance today; thank you for chilling with me!"
      ],
      "notes": "Final thoughts: strings in Ruby are becoming more efficient. The switch to default immutability is coming, and that brings opportunities for speedups and new features.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Final Q&A Session (Open Mic)",
      "content": [
        "Any remaining questions? Let's discuss and clarify anything from this talk."
      ],
      "notes": "",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Ruby's Cautious Decision-Making: A Decade in the Making",
      "content": [
        "The Ruby Way: Compatibility above all else",
        "• 10+ years of discussion for this feature",
        "• Multiple RFCs, endless bikeshedding, community input",
        "• 'Better safe than sorry' philosophy",
        "Why so slow? Ruby values backward compatibility over speed",
        "",
        "**The famous Ruby decision timeline:**",
        "• 2013: First discussions about frozen strings",
        "• 2016: Magic comment introduced",
        "• 2024: Chilled strings finally implemented",
        "• 2025+: Still debating R1/R2 phases",
        "",
        "Source: Ruby Issue #20205 - https://bugs.ruby-lang.org/issues/20205"
      ],
      "notes": "Emphasize Ruby's extremely cautious approach. This is a culture that values not breaking existing code over rapid innovation. Perfect example of Ruby's philosophy.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Your Action Plan: Embracing the Ruby Way (Taiwan Style)",
      "content": [
        "Today: Add # frozen_string_literal: true to new files",
        "Tomorrow: Use RuboCop to gradually update existing code",
        "For mutable needs: Use .dup or +'' (performance is now equal)",
        "Test with warnings: Warning[:deprecated] = true",
        "The Ruby philosophy: Slow and steady wins the race",
        "# Taiwan tech wisdom applied to Ruby\n# Be patient like TSMC's manufacturing cycles\n# Test thoroughly like semiconductor QA\n# Plan for the long term like infrastructure development",
        "Remember: Chilled strings are Ruby's way of saying '小心！' (be careful!)"
      ],
      "notes": "Connect the technical advice to Taiwan's methodical approach to technology development. End on a cultural note that resonates with the local audience.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Further Reading: Core Ruby Issues & RFCs",
      "content": [
        "📋 **Essential Ruby Tracker Issues:**",
        "• Ruby Issue #20205: Chilled strings implementation - https://bugs.ruby-lang.org/issues/20205",
        "• Ruby Issue #17104: Don't freeze interpolated strings - https://bugs.ruby-lang.org/issues/17104",
        "• Ruby Issue #8976: File-level frozen_string_literal pragma - https://bugs.ruby-lang.org/issues/8976",
        "• Ruby Issue #11473: Frozen string literal performance - https://bugs.ruby-lang.org/issues/11473",
        "",
        "🏛️ **Official Ruby Project Resources:**",
        "• Ruby Master Project: https://bugs.ruby-lang.org/projects/ruby-master",
        "• Ruby Documentation: https://ruby-doc.org/core-3.3.0/",
        "• Ruby Changelog: https://github.com/ruby/ruby/blob/master/NEWS.md"
      ],
      "notes": "These are the primary sources for all technical claims in this presentation. The Ruby bug tracker is the authoritative source for all feature discussions and implementations.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Further Reading: Implementation & Performance",
      "content": [
        "👨‍💻 **Key Contributors & Implementations:**",
        "• Jean Boussier: Lead implementer of chilled strings",
        "• Koichi Sasada: Ruby VM and performance work",
        "• Jeremy Evans: String optimization contributions",
        "",
        "📊 **Performance & Benchmarking:**",
        "• Ruby Performance Benchmarks: https://github.com/ruby-bench/ruby-bench-suite",
        "• Memory profiling tools: https://github.com/SamSaffron/memory_profiler",
        "• String allocation analysis in Rails apps",
        "",
        "🛠️ **Tools & Linting:**",
        "• RuboCop FrozenStringLiteralComment: https://docs.rubocop.org/rubocop/cops_style.html#stylefrozenstringliteralcomment",
        "• Ruby static analysis tools for string usage"
      ],
      "notes": "Practical resources for implementing and measuring the impact of frozen string literals in your applications.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Further Reading: Community & Alternative Implementations",
      "content": [
        "🌐 **Ruby Implementations:**",
        "• TruffleRuby Issues #2303, #2304: https://github.com/oracle/truffleruby/issues/2303",
        "• JRuby string handling documentation",
        "• MRI (Matz's Ruby) implementation details",
        "",
        "📝 **Community Resources:**",
        "• Ruby Weekly: https://rubyweekly.com/",
        "• Ruby conferences and talks on string performance",
        "• Blog posts by Ruby core team members",
        "",
        "🏢 **Enterprise Adoption:**",
        "• Rails guides on string optimization",
        "• Shopify's Ruby performance insights",
        "• GitHub's Ruby infrastructure learnings"
      ],
      "notes": "Community resources and real-world adoption stories. These show how different organizations have successfully implemented frozen string literals.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Connect on X! 🐦",
      "content": [
        "Follow me for more Ruby insights and updates:",
        "",
        "🐦 **@KuokkanenSampo**",
        "",
        "• Evil Martians Japan updates", 
        "• Occasionally Ruby tips (maybe)",
        "• Pictures of my Honda Beat"
      ],
      "notes": "Show QR code for X account. Encourage attendees to connect for ongoing Ruby discussions and updates.",
      "image_path": "qr_code_x_account.png",
      "slide_type": "mixed"
    },
    {
      "title": "Get the Presentation Tool! 🛠️",
      "content": [
        "This presentation was created with i_speaker:",
        "• AI-powered Ruby gem for creating presentations",
        "• Interactive console interface with dual AI support",
        "• Multiple export formats (Markdown, Slidev, JSON)",
        "",
        "🔗 **Source code and gem available at:**"
      ],
      "notes": "Show QR code for the i_speaker GitHub repository. This tool was used to create this presentation.",
      "image_path": "qr_code_github_i_speaker.png",
      "slide_type": "mixed"
    },
    {
      "title": "謝謝 Taiwan! Thank You! 🇹🇼❄️",
      "content": [
        "Thank you RubyConf Taiwan for the warm welcome!",
        "Key takeaways:",
        "• Ruby prioritizes stability over speed (a lesson for all of us)",
        "• Chilled strings = Ruby's careful approach to change",
        "• Taiwan's tech culture aligns with Ruby's philosophy",
        "Sources and further reading:",
        "• Ruby Issue #20205: https://bugs.ruby-lang.org/issues/20205",
        "• Jean Boussier's chilled strings implementation",
        "• RuboCop Style/FrozenStringLiteralComment",
        "Stay connected: Let's keep the Ruby Taiwan community strong! 💎"
      ],
      "notes": "End with gratitude to the local community and provide proper sources for follow-up.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "🏁 Easter Egg: Taiwan Flag Waving in the Wind! 🇹🇼",
      "content": [
        "A fun finale using frozen strings! ❄️",
        "",
        "🇹🇼 **Taiwan flag waving animation**",
        "Built with all frozen strings for performance!",
        "",
        "Features:",
        "• ASCII art Taiwan flag",
        "• 30 frames of smooth animation",
        "",
        "🎯 **Surprise!** Press ENTER to see the Taiwan flag wave!"
      ],
      "notes": "EASTER EGG: This is a fun surprise ending! The animation creates a waving effect with the Taiwan flag emoji scattered across a wave pattern. All strings are frozen for maximum performance. The animation runs for about 1.5 seconds showing the flag 'fluttering'. This celebrates both Taiwan and Ruby's frozen strings!",
      "image_path": null,
      "slide_type": "content"
    }
  ],
  "estimated_duration": 127,
  "completion_status": "67/67 slides completed"
}