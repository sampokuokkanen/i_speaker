{
  "title": "What is happening with strings in Ruby and why is it feeling chilly? 🥶",
  "description": "Explore the recent changes to frozen string literals in Ruby, their implications for everyday Rubyists, and why strings are feeling 'chilly' in the latest versions.",
  "target_audience": "RubyConf Taiwan attendants",
  "duration_minutes": 30,
  "slides": [
    {
      "title": "Welcome to RubyConf Taiwan! 🇹🇼",
      "content": [
        "Hello Ruby developers of Taiwan! 你好！",
        "Taiwan's tech scene: From semiconductor leadership to Ruby innovation",
        "Why Taiwan matters in the Ruby ecosystem:",
        "• Strong open-source community",
        "• Active Ruby developers and companies",
        "• Bridge between Eastern and Western Ruby communities",
        "Today's journey: How Ruby makes decisions (spoiler: very carefully!)"
      ],
      "notes": "Acknowledge the local audience and Taiwan's importance in tech. Set the stage for discussing Ruby's cautious decision-making process.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Ruby Demo: Let's Try Chilled Strings! 🧊",
      "content": [
        "Time to see chilled strings in action! 🧊",
        "",
        "What we'll demonstrate:",
        "• Create a string literal",
        "• Check if it's frozen", 
        "• Try to mutate it",
        "• See the warning message",
        "",
        "🎯 **Interactive Demo!** Press ENTER to run Ruby code!"
      ],
      "notes": "DEMO SLIDE: Press ENTER to execute the Ruby code! This will show chilled strings behavior with real Ruby execution.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Demo Code 📝",
      "content": [
        "```ruby",
        "# Our demo with Taiwan companies:",
        "company = \"台積電\"  # TSMC",
        "puts company.frozen?  # => true",
        "",
        "# Try to mutate it:",
        "company << \" 台灣\"",
        "# ⚠️  Warning: literal string will be frozen",
        "",
        "puts company         # => \"台積電 台灣\"", 
        "puts company.frozen? # => false",
        "```"
      ],
      "notes": "Code details for reference. The actual execution happens on the previous slide.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "About Your Speaker: Sampo Kuokkanen 🚀",
      "content": [
        "Head of Evil Martians Japan Office",
        "Building bridges between Ruby communities worldwide",
        "• Co-presented at RubyWorld 2024 with Andrey Novikov",
        "Why I'm here: Taiwan + Japan = Ruby powerhouse in Asia!"
      ],
      "notes": "Brief introduction. Emphasize the Japan-Taiwan connection and my role in bridging Ruby communities. Mention Evil Martians' commitment to the Asian Ruby scene.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The String Performance Problem in Ruby",
      "content": [
        "Ruby's mutable strings: convenient but costly",
        "20-30% of Ruby execution time spent in garbage collection",
        "String allocations are a major contributor to GC pressure",
        "The solution: Immutability through frozen and chilled strings"
      ],
      "notes": "Start with a relatable problem statement. Ask audience: 'How many of you have dealt with memory issues in your Ruby apps?' Use this to establish why string handling matters to everyone, not just core developers.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Introduction",
      "content": [],
      "notes": "",
      "image_path": "/Users/sampokuokkanen/i_speaker/Keeping it Ruby_ Why Your Product Needs a Ruby SDK-2.jpg",
      "slide_type": "image"
    },
    {
      "title": "Evil Martians: Product Development for the Web 👽",
      "content": [
        "Design + Development + Growth consultancy",
        "• Open Source contributors (Stimulus, AnyCable, PostCSS)",
        "• Ruby/Rails experts since 2005",
        "• Global team: SF, NYC, Barcelona, Lisbon, Japan",
        "Japan office established: May 2022 🇯🇵",
        "Our mission in Asia: Strengthen Ruby communities!"
      ],
      "notes": "Quick Evil Martians intro. Emphasize our commitment to open source and the Asian Ruby community.",
      "image_path": "/Users/sampokuokkanen/i_speaker/Keeping it Ruby_ Why Your Product Needs a Ruby SDK-3.jpg",
      "slide_type": "mixed"
    },
    {
      "title": "Evil Martians Japan",
      "content": [],
      "notes": "",
      "image_path": "/Users/sampokuokkanen/i_speaker/Keeping it Ruby_ Why Your Product Needs a Ruby SDK-4.jpg",
      "slide_type": "mixed"
    },
    {
      "title": "The Evolution of Frozen Strings in Ruby",
      "content": [
        "Pre-2.3: Strings always mutable, developers used ''.freeze for constants",
        "Ruby 2.1: Optimized .freeze to deduplicate identical literals, reducing memory usage",
        "Ruby 2.3: Introduced # frozen_string_literal: true pragma for opt-in immutability",
        "Ruby 3.0 plan: Default frozen literals postponed due to compatibility concerns",
        "Ruby 3.3+: Introduction of 'chilled strings' as transition mechanism"
      ],
      "notes": "Present the history as a clear timeline. Emphasize the progression from manual freezing to pragma to the current chilled string approach. This creates a coherent narrative instead of fragmented information.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Why Chilled Strings? The Migration Challenge",
      "content": [
        "The goal: Default frozen literals for performance",
        "The problem: Breaking existing code that mutates literals",
        "The solution: Gradual transition with warnings",
        "Chilled strings = Frozen initially + Warning on mutation",
        "This approach maintains compatibility while encouraging best practices"
      ],
      "notes": "Explain the 'why' before the 'how'. This addresses the issue of premature technical depth. Use the chilly metaphor consistently - strings are 'chilled' (frozen) but can be 'warmed up' (mutated) with a warning.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Chilled Strings: The Technical Deep Dive",
      "content": [
        "Ruby 3.3 introduces the putchilledstring instruction",
        "Chilled strings: appear frozen but can 'thaw' with warnings",
        "Key insight: Mixed benchmark results in real applications",
        "# Technical implementation (from Ruby Issue #20205)\n# putchilledstring creates strings with special flags\n# STR_CHILLED flag marks the string as 'thawed-on-write'\n# .frozen? initially returns true (controversial decision!)\n# First mutation: warning + string becomes mutable\n# Performance impact: minimal overhead (< 1%)",
        "Reality: Performance gains are often marginal (5-30%)",
        "The real goal: Gradual migration to immutability"
      ],
      "notes": "Present the technical details in a clear, sequential manner. Focus on the behavior rather than low-level implementation details. Use the example to make the concept concrete.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Why Chilled Strings? The Migration Challenge",
      "content": [
        "Goal: Make string literals frozen by default (Ruby 4.0)",
        "Challenge: Backward compatibility with existing code",
        "Solution: Gradual transition through 'chilled' strings",
        "Chilled strings = frozen initially, warn on mutation"
      ],
      "notes": "Explain the rationale before diving into implementation. Use an analogy: 'Chilled strings are like training wheels - they let you know when you're doing something that won't work in the future, but won't crash your program immediately.'",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Evolution of String Immutability in Ruby",
      "content": [
        "Ruby 2.1: Optimized .freeze for deduplication",
        "Ruby 2.3: Introduced # frozen_string_literal: true pragma",
        "Ruby 2.7+: Added deprecation warnings for mutating literals",
        "Ruby 3.3: Implemented chilled strings (R0 transition phase)",
        "Future (Ruby 4.0): Planned default frozen literals (R2)"
      ],
      "notes": "Present this as a clear timeline visualization. Emphasize that this has been a decade-long journey showing Ruby's commitment to both performance and backward compatibility. This replaces the repetitive historical content across multiple slides.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The State of Strings in Ruby (Part 2)",
      "content": [
        "Starting with Ruby 3.3 (planned R0), strings in files without a `# frozen_string_literal` comment use the new `putchilledstring` instruction.",
        "The `putchilledstring` opcode marks the string as frozen (via STR_CHILLED and FL_FREEZE flags), so `String#frozen?` returns true at first.",
        "On the first mutating operation (e.g. `<<`), the chilled string loses its frozen status and emits a warning instead of raising a `FrozenError`."
      ],
      "notes": "In Ruby 3.3 (core discussion calls this R0), the behavior is: no pragma -> string is chilled. It's frozen but thaws on mutation with a warning. Files with explicit comments (true/false) behave unchanged.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Ruby Archaeology: The Origins of Frozen Strings",
      "content": [
        "Ruby’s design was pragmatic: mutable strings by default (like Perl) made life easier for programmers at some performance cost.",
        "Over time, developers demanded immutability for performance; Ruby added deduplication on `.freeze` in 2.1.",
        "By Ruby 2.3, the magic comment emerged to freeze literals in a file when needed – an important milestone in Ruby’s string evolution."
      ],
      "notes": "A lighthearted start – but the technical core is that Ruby always favored mutable strings for flexibility. The move to immutability is recent and driven by memory/GC concerns.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Ruby Archaeology: The Origins of Frozen Strings",
      "content": [
        "Before frozen literals, people often wrote `''.freeze` on constants to avoid duplicate allocations. Ruby 2.1 changed behavior so that freezing identical literals would dedupe them in memory.",
        "This saved RAM and reduced GC churn. For example, avoiding one redundant allocation per call (like an HTTP header) could cut 20–30% of GC work.",
        "The `# frozen_string_literal: true` comment (Ruby 2.3) formalized this idea: any literal in that file would be deduplicated and immutable.",
        "Ultimately, Matz aims for default immutability, but needed a smooth migration plan (hence staged deprecation and warnings)."
      ],
      "notes": "History recap: how `.freeze` became more efficient (dedupe), how that led to the magic comment, and why it’s needed (performance/GC).",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Ruby's String Class History (Deeper Dive)",
      "content": [
        "Ruby 1.9: Added encoding support (m17n) - strings remained mutable",
        "Ruby 2.1: Introduced frozen string deduplication for memory savings",
        "Ruby 2.3: Added `# frozen_string_literal: true` pragma",
        "JRuby: Uses Java strings internally but maintains Ruby's mutable semantics",
        "TruffleRuby: Interpolated strings with pragma stay mutable (aligns with Ruby 3.0 behavior)"
      ],
      "notes": "Implementation note: MRI vs JRuby vs Truffle. We focus on MRI, but JRuby has its own approach (Java strings) and Truffle leaves dynamic strings mutable (but core code is frozen).",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Real-World Performance Gains",
      "content": [
        "Let's benchmark frozen vs mutable strings in real-time! 🚀",
        "",
        "```ruby",
        "require 'benchmark'",
        "",
        "# Test with 1 million string concatenations",
        "iterations = 1_000_000",
        "puts \"Testing #{iterations} string concatenations...\\n\\n\"",
        "",
        "# Capture times for comparison",
        "mutable_time = nil",
        "frozen_time = nil",
        "",
        "Benchmark.bm(10) do |x|",
        "  mutable_time = x.report('mutable:') do",
        "    iterations.times { 'Hello ' + 'World' }",
        "  end",
        "  ",
        "  frozen_time = x.report('frozen:') do",
        "    iterations.times { 'Hello '.freeze + 'World'.freeze }",
        "  end",
        "end",
        "",
        "# Calculate and display the performance difference",
        "improvement = ((mutable_time.real - frozen_time.real) / mutable_time.real * 100).round(1)",
        "puts \"\\n🎉 Frozen strings are #{improvement}% faster!\"",
        "puts \"⏱️  Saved #{(mutable_time.real - frozen_time.real).round(3)} seconds\"",
        "```",
        "",
        "🎯 **Live Benchmark!** Press ENTER to run this performance test!",
        "See the actual time difference in seconds!"
      ],
      "notes": "INTERACTIVE BENCHMARK: Press ENTER to run the performance comparison live! This will show the actual time difference between mutable and frozen strings. The results typically show 20-35% improvement with frozen strings. Make sure to point out the time difference to the audience.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "What Are Chilled Strings? (Example)",
      "content": [
        "Example: Without `# frozen_string_literal`, Ruby 3.3 compiles `s = \"hello\"` as a chilled string. If `s` is never mutated, it stays frozen and reused.",
        "If later code does `s << ' world'`, Ruby emits a warning (`literal string will be frozen in future`) and then allows the mutation (s becomes mutable).",
        "For most code where literals aren’t changed, chilled strings behave exactly like frozen ones – the literal is shared instead of duplicated."
      ],
      "notes": "We walk through code: chilled string then thawed on mutation. This means in practice you can leave code as-is; if you do mutate a literal, you get a warning and then normal behavior.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Impact on Everyday Rubyists: Performance Considerations",
      "content": [
        "Freezing literals cuts object allocations: identical constants can be shared, reducing GC work.",
        "Benchmarks show gains: one example found a 22% speedup concatenating strings 1M times with frozen literals in Ruby 2.7.",
        "In Ruby 3.4-dev, a similar test was ~34% faster with frozen literals.",
        "Rails has reported significant memory savings from frozen literals; since Ruby often spends ~20-30% time in GC, these savings yield CPU speedups.",
        "Ruby 3.3 also optimized `String.dup`, so developers can now use `.dup` (for mutability) without a performance penalty."
      ],
      "notes": "Performance recap: frozen literals mean fewer allocations and less GC. We saw actual numbers from the community, and note that Ruby 3.3 made `.dup` as fast as `+`.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Ruby's Cautious Decision-Making: A Decade in the Making",
      "content": [
        "The Ruby Way: Compatibility above all else",
        "• 10+ years of discussion for this feature",
        "• Multiple RFCs, endless bikeshedding, community input",
        "• 'Better safe than sorry' philosophy",
        "Why so slow? Ruby values backward compatibility over speed",
        "# The famous Ruby decision timeline\n# 2013: First discussions about frozen strings\n# 2016: Magic comment introduced\n# 2024: Chilled strings finally implemented\n# 2025+: Still debating R1/R2 phases",
        "Source: Ruby Issue #20205 - https://bugs.ruby-lang.org/issues/20205"
      ],
      "notes": "Emphasize Ruby's extremely cautious approach. This is a culture that values not breaking existing code over rapid innovation. Perfect example of Ruby's philosophy.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Impact on Everyday Rubyists",
      "content": [
        "Code with `# frozen_string_literal: true` is unaffected – literals were already frozen.",
        "Without the pragma, literal strings will warn once on mutation and then become mutable (chilled behavior).",
        "Common idioms (`dup if frozen?`) still work: a chilled string reports `.frozen? == true`, so `dup` yields a normal copy.",
        "⚠️ GOTCHA: Chilled string as Hash key bug - if you use a chilled string as a hash key then mutate it, the hash gets corrupted (Ruby Issue #20205)",
        "Workflow tip: Add `frozen_string_literal` to new files, and use `str.dup` or `+''` when you need a mutable copy (now equally fast)."
      ],
      "notes": "Practical: if you already use `# frozen_string_literal: true`, nothing changes. If not, you’ll get a warning on first mutation. Continue to use `dup`/`+` for copies; they’re fast now. Watch out for the hash-key issue.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Real-World Impact: A Case Study",
      "content": [
        "**Lobsters.rs (2019, Ruby 2.6)**: ~5% faster with frozen literals",
        "**String concatenation loop (Ruby 2.7, 2020)**: 22% performance gain",
        "**Ruby 3.4-dev (2024)**: 34% faster with frozen string literals",
        "**GitHub.com (Ruby 3.3, 2024)**: 5% fewer allocations using Symbol#name",
        "",
        "💡 **Key insight**: Even 5% matters at scale!"
      ],
      "notes": "Case studies: see actual speed-ups from frozen literals, and note that even large systems like GitHub see ~5% fewer allocations by changing symbol-to-string behavior.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The R0/R1/R2 Migration Strategy: Ruby's Master Plan",
      "content": [
        "Ruby's three-phase approach:",
        "• **R0** (Ruby 3.3): Chilled strings + warnings",
        "• **R1** (Future): Warnings always visible",  
        "• **R2** (Ruby 4.0+): Frozen by default",
        "",
        "🎯 **The reality**: Timeline is flexible by design",
        "Ruby won't break your code for small performance gains!"
      ],
      "notes": "Based on Ruby Issue #20205. Highlight that even the timeline is tentative - Ruby doesn't commit to breaking changes lightly.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Road Not Taken: \"hello\"f Suffix Syntax",
      "content": [
        "Before magic comments, Ruby considered a different approach:",
        "",
        "**The \"f\" suffix proposal (Ruby Issue #8579):**",
        "```ruby",
        "name = \"Hello World\"f      # Frozen string",
        "greeting = \"Welcome\"f      # Frozen string", 
        "```",
        "",
        "vs. current approach:",
        "```ruby",
        "# frozen_string_literal: true",
        "name = \"Hello World\"       # File-level magic",
        "```"
      ],
      "notes": "Historical context: Ruby considered f-suffix but chose magic comments instead.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Why \"hello\"f Was Rejected",
      "content": [
        "Community feedback was negative:",
        "• **\"Ugly\" syntax** - Didn't feel Ruby-like",
        "• **Too verbose** - Every string needs tagging",
        "• **Breaking change** - Incompatible with older Ruby",
        "• **RubyShift 2013** - Audience reaction was poor",
        "",
        "✨ **Ruby chose elegance**: File-level magic comments",
        "",
        "Source: https://bugs.ruby-lang.org/issues/8579"
      ],
      "notes": "Historical context: Ruby seriously considered f-suffix syntax (like \"text\"f) but community reaction was negative. The magic comment approach was more Ruby-like - elegant, file-level, and doesn't require tagging every string. This shows Ruby's commitment to beautiful, readable code.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Best Practices for Using Frozen String Literals",
      "content": [
        "**1. Add the magic comment to new files:**",
        "`# frozen_string_literal: true`",
        "",
        "**2. When you need mutable strings:**", 
        "• Use `str.dup` (optimized in Ruby 3.3+)",
        "• Or use `str + ''` for concatenation",
        "",
        "**3. Enable warnings in development:**",
        "`Warning[:deprecated] = true`"
      ],
      "notes": "Practical advice for developers. Tools like RuboCop can auto-insert the magic comment.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Code Example: Frozen Strings in Practice",
      "content": [
        "```ruby",
        "# frozen_string_literal: true",
        "",
        "HEADER = \"Processing: \"  # Frozen automatically",
        "",
        "def process(input)",
        "  # ❌ WRONG: HEADER << input  # FrozenError!",
        "  # ✅ RIGHT: Use .dup",
        "  result = HEADER.dup",
        "  result << input",
        "end",
        "```"
      ],
      "notes": "Recommendations: use the magic comment to benefit immediately. Also update your code: prefer `dup` instead of bang methods, since dup is now fast. And run tests with warnings enabled to find any problems.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Alternate Syntax: `'f'` Suffix",
      "content": [
        "A proposed approach was an `f`-suffix on string literals (e.g. `\"hello\"f`) to freeze them.",
        "Criticisms: this syntax was considered \"ugly\" and incompatible with older Ruby (it required tagging each literal).",
        "In a RubyShift 2013 presentation, audience reaction to the `f`-suffix was reported as negative.",
        "Consequently, Ruby 2.3 instead adopted the file-level `# frozen_string_literal: true` magic comment approach."
      ],
      "notes": "History: an `f`-suffix was once discussed (to write frozen literals as `\"text\"f`), but it was rejected in favor of the magic comment.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Ruby Core Decision Timeline",
      "content": [
        "The plan to make literals frozen by default in Ruby 3.0 was abandoned due to backward-compatibility concerns.",
        "Instead, the core team agreed on a staged migration: R0 (e.g. Ruby 3.4) adds deprecation warnings, R1 (later 3.x) shows warnings unconditionally, and R2 (Ruby 4.0) eventually freezes literals by default.",
        "However, Matz has stated that Ruby 4.0 (target ~2025) will still *not* enable default frozen literals yet.",
        "This cautious, decade-long process reflects the community’s emphasis on compatibility and a smooth transition."
      ],
      "notes": "Summary: Ruby 2.3’s default-change was delayed, and the R0/R1/R2 timeline was set. Even so, default freeze in 4.0 is postponed, pending broad adoption and testing.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Future of Frozen String Literals",
      "content": [
        "The long-term plan is to make frozen string literals the default (likely around Ruby 4.0).",
        "Eventually the magic comment will be unnecessary. Deprecation periods ensure a smooth transition.",
        "Gem maintainers should audit their code: add the pragma where safe, or avoid mutating literals in libraries.",
        "These changes will allow further optimizations under the hood (e.g. static string internals, CoW mechanisms)."
      ],
      "notes": "Looking ahead: prepare for Ruby 4.0 default. The ecosystem needs to opt-in now to minimize friction. In return we get faster strings across the board.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Future of Frozen String Literals (Specs)",
      "content": [
        "In Ruby 3.4+, the scheme is: R0 = warnings on mutation if no pragma, R1 = warnings always, R2 = freeze by default.",
        "Ruby 3.4 already issues warnings for mutating literals without the comment.",
        "Symbol-related changes (Symbol#to_s now chilled) and other corner cases are being addressed as part of this transition.",
        "The final switch (default freeze) will come in a future release (likely Ruby 4.0), after a full deprecation cycle."
      ],
      "notes": "Specifically: Ruby 3.4 uses `putchilledstring` by default and warns on mutation:​. Further steps (R1/R2) will follow in 3.5+ and Ruby 4.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Impact on Symbol Strings",
      "content": [
        "Symbols themselves are immutable as always. But converting symbols to strings (`#to_s`) now plays better with frozen-literal strategy.",
        "Ruby 3.4 implemented that `Symbol#to_s` returns a chilled string, reducing string allocations:​.",
        "This change was driven by usage patterns (often `to_s` on symbols in hot paths) and gives performance win without changing APIs.",
        "In practice, you shouldn’t need to change code: `:foo.to_s` behaves as before, but now yields a string that will warn if mutated."
      ],
      "notes": "A quick note on symbols: to reduce allocations, Ruby will mark the string from `Symbol#to_s` as chilled. No direct action needed in your code yet.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Real-World Impact: Another Case Study",
      "content": [
        "Enterprise apps: developers report that turning on frozen literals in Rails apps cuts memory use and slightly speeds up request throughput.",
        "The cumulative effect of many small literal optimizations can be significant under load (e.g. caching, tokenization).",
        "Tools like RuboCop (Style/FrozenStringLiteralComment) help automate the change across a codebase.",
        "Bottom line: teams using frozen literals saw smoother operation and no major breakage, validating the change."
      ],
      "notes": "Another data point: adoption in Rails and large codebases has been largely positive. Profilers show reduced GC and similar or improved latency.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Migration Guide: Preparing Your Codebase",
      "content": [
        "Step 1: Enable warnings in development (Warning[:deprecated] = true)",
        "Step 2: Use RuboCop to add # frozen_string_literal: true automatically",
        "Step 3: Fix warnings by adding .dup or +'' where mutation is needed",
        "Step 4: Test thoroughly - especially edge cases with Hash keys",
        "Step 5: Monitor performance and memory usage improvements"
      ],
      "notes": "This addresses the critical gap identified in the analysis. Make this actionable with specific commands and tools. Emphasize that this is a gradual process that can be done incrementally. Provide a clear path forward for attendees to apply this knowledge.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Ruby's Philosophy: Lessons for Taiwan's Tech Scene",
      "content": [
        "What Ruby's cautious approach teaches us:",
        "• Stability enables innovation (like Taiwan's semiconductor industry)",
        "• Community consensus > individual brilliance",
        "• Long-term thinking over quick wins",
        "Taiwan's tech wisdom parallels Ruby's:",
        "• Precision and reliability first (TSMC approach)",
        "• Careful iteration and improvement",
        "• Building sustainable ecosystems, not just features",
        "Question: How does your team balance innovation vs. stability?"
      ],
      "notes": "Connect Ruby's development philosophy to Taiwan's tech culture. Both prioritize long-term stability and careful decision-making.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Interactive Break: Q&A Session",
      "content": [
        "Take a few minutes to ask any questions and clarify doubts you may have about frozen and chilled strings.",
        "特別歡迎中文問題! (Chinese questions especially welcome!)"
      ],
      "notes": "",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Best Practices for Testing with Frozen String Literals",
      "content": [
        "Enable deprecation warnings in tests (`Warning[:deprecated] = true` or `ruby -W:deprecated`) to catch literal-mutation issues.",
        "Use RuboCop’s FrozenStringLiteralComment cop to add or check the magic comment.",
        "Test for immutability: e.g. verify that constants aren’t modified by functions, or use `assert_equal constant, constant.dup`.",
        "Consider continuous integration: treat warnings as errors during upgrade to catch any new mutations."
      ],
      "notes": "In testing, we want to fail fast. For example, enable Ruby warnings so that any literal mutation shows up in CI (RSpec is working on this; Minitest already does it).",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Transition Slide: We’re Halfway There!",
      "content": [
        "Let’s take a quick glance back at what we’ve covered so far.",
        "History of immutable strings, frozen_string_literal magic, chilled strings, and performance impacts."
      ],
      "notes": "Quick summary: we’ve traced the story up to current chilled strings and performance. Next we’ll continue with quality impacts and final examples.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "The Impact on Code Quality and Readability",
      "content": [
        "Immutable strings can make code safer (fewer unintended side effects). They reduce bugs where a string constant changes underfoot.",
        "However, some developers have noted surprises: e.g. using a frozen string constant in a destructive method (like `transform_values!`) can quietly modify the shared data unexpectedly.",
        "In general, using frozen literals pushes you to think functionally (avoid side effects). It can improve clarity by removing manual `.freeze` calls, but requires awareness of immutability.",
        "With warnings and tests in place, most teams find frozen literals improve code quality, as mutation becomes explicit (`dup` or reassignment)."
      ],
      "notes": "Reflection: immutability is a trade-off. It avoids a class of bugs, but can surprise developers not expecting it. The community discussion noted that behavior like in this example was new.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Real-World Impact: A Final Example",
      "content": [
        "Example (web request header): Without frozen literals, code often did `env[HTTP_PATH_INFO.dup]` on each request, allocating a new string each time. With a frozen literal, that extra allocation is eliminated.",
        "Jean Boussier explains that avoiding such duplicate allocations significantly reduces GC overhead (Ruby spent ~20-30% time in GC before).",
        "Thus freezing a literal key (or using a chilled string) removes a trivial inefficiency that adds up under high load.",
        "Tiny optimizations like this, multiplied across a large app, yield measurable performance improvements in production."
      ],
      "notes": "Concrete snippet: turning `'HTTP_PATH_INFO'` into a frozen literal means `env[...]` avoids a `.dup` every time. That one allocation per request disappears.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Interactive Break 3: Exercise - Try It Out!",
      "content": [
        "Take a few minutes: add `# frozen_string_literal: true` to a Ruby file or script, and see if any warnings appear or behavior changes."
      ],
      "notes": "",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Conclusion (Part 1): Recap and Reflection",
      "content": [
        "We summarized the history: Ruby 2.3’s frozen-string pragma through Ruby 3.3’s chilled-strings change.",
        "Frozen literals reduce GC and speed up code in many cases.",
        "Chilled strings provide a gentle migration (warn vs error) to default immutability.",
        "Key takeaway: use frozen literals now and explicitly handle mutability to prepare for future Ruby defaults."
      ],
      "notes": "Recap: we covered the key points and rationale behind frozen strings and chilled strings, and why it matters for performance and safety.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Conclusion (Part 2): The Future of Ruby Strings",
      "content": [
        "The likely future: Ruby 4.0 will default to frozen literals, as envisioned years ago.",
        "By then, code will have adapted (we’ll use `dup` or constructors for mutable needs) and will have benefitted from the optimization.",
        "Beyond freezing, Ruby may introduce further innovations (e.g. string dedup internals, CoW, new literal syntax).",
        "Until then, frozen literals remain a great tool for performance today; thank you for chilling with me!"
      ],
      "notes": "Final thoughts: strings in Ruby are becoming more efficient. The switch to default immutability is coming, and that brings opportunities for speedups and new features.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Final Q&A Session (Open Mic)",
      "content": [
        "Any remaining questions? Let's discuss and clarify anything from this talk."
      ],
      "notes": "",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Ruby's Cautious Decision-Making: A Decade in the Making",
      "content": [
        "The Ruby Way: Compatibility above all else",
        "• 10+ years of discussion for this feature",
        "• Multiple RFCs, endless bikeshedding, community input",
        "• 'Better safe than sorry' philosophy",
        "Why so slow? Ruby values backward compatibility over speed",
        "",
        "**The famous Ruby decision timeline:**",
        "• 2013: First discussions about frozen strings",
        "• 2016: Magic comment introduced",
        "• 2024: Chilled strings finally implemented",
        "• 2025+: Still debating R1/R2 phases",
        "",
        "Source: Ruby Issue #20205 - https://bugs.ruby-lang.org/issues/20205"
      ],
      "notes": "Emphasize Ruby's extremely cautious approach. This is a culture that values not breaking existing code over rapid innovation. Perfect example of Ruby's philosophy.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Your Action Plan: Embracing the Ruby Way (Taiwan Style)",
      "content": [
        "Today: Add # frozen_string_literal: true to new files",
        "Tomorrow: Use RuboCop to gradually update existing code",
        "For mutable needs: Use .dup or +'' (performance is now equal)",
        "Test with warnings: Warning[:deprecated] = true",
        "The Ruby philosophy: Slow and steady wins the race",
        "# Taiwan tech wisdom applied to Ruby\n# Be patient like TSMC's manufacturing cycles\n# Test thoroughly like semiconductor QA\n# Plan for the long term like infrastructure development",
        "Remember: Chilled strings are Ruby's way of saying '小心！' (be careful!)"
      ],
      "notes": "Connect the technical advice to Taiwan's methodical approach to technology development. End on a cultural note that resonates with the local audience.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Further Reading: Core Ruby Issues & RFCs",
      "content": [
        "📋 **Essential Ruby Tracker Issues:**",
        "• Ruby Issue #20205: Chilled strings implementation - https://bugs.ruby-lang.org/issues/20205",
        "• Ruby Issue #17104: Don't freeze interpolated strings - https://bugs.ruby-lang.org/issues/17104",
        "• Ruby Issue #8976: File-level frozen_string_literal pragma - https://bugs.ruby-lang.org/issues/8976",
        "• Ruby Issue #11473: Frozen string literal performance - https://bugs.ruby-lang.org/issues/11473",
        "",
        "🏛️ **Official Ruby Project Resources:**",
        "• Ruby Master Project: https://bugs.ruby-lang.org/projects/ruby-master",
        "• Ruby Documentation: https://ruby-doc.org/core-3.3.0/",
        "• Ruby Changelog: https://github.com/ruby/ruby/blob/master/NEWS.md"
      ],
      "notes": "These are the primary sources for all technical claims in this presentation. The Ruby bug tracker is the authoritative source for all feature discussions and implementations.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Further Reading: Implementation & Performance",
      "content": [
        "👨‍💻 **Key Contributors & Implementations:**",
        "• Jean Boussier: Lead implementer of chilled strings",
        "• Koichi Sasada: Ruby VM and performance work",
        "• Jeremy Evans: String optimization contributions",
        "",
        "📊 **Performance & Benchmarking:**",
        "• Ruby Performance Benchmarks: https://github.com/ruby-bench/ruby-bench-suite",
        "• Memory profiling tools: https://github.com/SamSaffron/memory_profiler",
        "• String allocation analysis in Rails apps",
        "",
        "🛠️ **Tools & Linting:**",
        "• RuboCop FrozenStringLiteralComment: https://docs.rubocop.org/rubocop/cops_style.html#stylefrozenstringliteralcomment",
        "• Ruby static analysis tools for string usage"
      ],
      "notes": "Practical resources for implementing and measuring the impact of frozen string literals in your applications.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "Further Reading: Community & Alternative Implementations",
      "content": [
        "🌐 **Ruby Implementations:**",
        "• TruffleRuby Issues #2303, #2304: https://github.com/oracle/truffleruby/issues/2303",
        "• JRuby string handling documentation",
        "• MRI (Matz's Ruby) implementation details",
        "",
        "📝 **Community Resources:**",
        "• Ruby Weekly: https://rubyweekly.com/",
        "• Ruby conferences and talks on string performance",
        "• Blog posts by Ruby core team members",
        "",
        "🏢 **Enterprise Adoption:**",
        "• Rails guides on string optimization",
        "• Shopify's Ruby performance insights",
        "• GitHub's Ruby infrastructure learnings"
      ],
      "notes": "Community resources and real-world adoption stories. These show how different organizations have successfully implemented frozen string literals.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "謝謝 Taiwan! Thank You! 🇹🇼❄️",
      "content": [
        "Thank you RubyConf Taiwan for the warm welcome!",
        "Key takeaways:",
        "• Ruby prioritizes stability over speed (a lesson for all of us)",
        "• Chilled strings = Ruby's careful approach to change",
        "• Taiwan's tech culture aligns with Ruby's philosophy",
        "Sources and further reading:",
        "• Ruby Issue #20205: https://bugs.ruby-lang.org/issues/20205",
        "• Jean Boussier's chilled strings implementation",
        "• RuboCop Style/FrozenStringLiteralComment",
        "Stay connected: Let's keep the Ruby Taiwan community strong! 💎"
      ],
      "notes": "End with gratitude to the local community and provide proper sources for follow-up.",
      "image_path": null,
      "slide_type": "content"
    },
    {
      "title": "🏁 Easter Egg: Taiwan Flag Waving in the Wind! 🇹🇼",
      "content": [
        "A fun finale: Taiwan flag waving on a pole using frozen strings!",
        "",
        "```ruby",
        "# Load and execute the Taiwan flag waving animation!",
        "# All code is in a separate file for easy testing",
        "",
        "require_relative './taiwan_flag_fireworks'",
        "",
        "# Run the amazing Taiwan flag waving animation",
        "run_taiwan_fireworks",
        "```",
        "",
        "**Preview of taiwan_flag_fireworks.rb:**",
        "```ruby",
        "# frozen_string_literal: true",
        "",
        "# All strings frozen for performance! ❄️",
        "FLAG = '🇹🇼'.freeze",
        "FLAG_POLE = '║'.freeze",
        "WIND_CHARS = [' ', '~', '≈', '≋', '∿'].freeze",
        "",
        "# Calculate wave effect - sine waves for realistic motion",
        "wave_offset = Math.sin((x * 0.3) + (frame * 0.2)) * 2",
        "vertical_wave = Math.sin((y * 0.4) + (frame * 0.15)) * 1",
        "",
        "# Taiwan flag attached to pole, waving in wind",
        "# Wind intensity affects character display",
        "# 30 frames of smooth waving motion",
        "```",
        "",
        "🎯 **Surprise!** Press ENTER to see the Taiwan flag wave!"
      ],
      "notes": "EASTER EGG: This is a fun surprise ending! The animation creates a waving effect with the Taiwan flag emoji scattered across a wave pattern. All strings are frozen for maximum performance. The animation runs for about 1.5 seconds showing the flag 'fluttering'. This celebrates both Taiwan and Ruby's frozen strings!",
      "image_path": null,
      "slide_type": "content"
    }
  ],
  "estimated_duration": 127,
  "completion_status": "49/49 slides completed"
}